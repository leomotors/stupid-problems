\documentclass[11pt,a4paper]{article}

\usepackage{res/style_th}

\begin{document}

\begin{problem}{Mark SUCKerberg}{standard input}{standard output}{3 seconds}{512 megabytes}

ใน Social Media แห่งหนึ่งที่มีชื่อว่า Facebook การที่ทุกคนมีอิสรภาพในการโพสต์สิ่งที่เราต้องการหรือ
ที่เรียกว่า Free Speech นั้นก็เปรียบเสมือนดาบสองคมก็ว่าได้ ในโลกแห่งนี้มีผู้ปรารถนาร้ายที่จ้องจะโพสต์
สิ่งที่ไม่เหมาะสม

เพื่อต่อกรกับโพสต์ที่ไม่เหมาะสม คุณจึงได้รับหน้าที่ให้สร้าง AI ที่ฉลาดและมีประสิทธิภาพเพื่อมาดูแล
สังคมเมตาเวิร์สแห่งนี้

เพื่อความง่าย โพสต์แต่ละโพสต์นั้นจะเป็น bitstring ความยาว $S_i$ ($1 \le S_i \le 256$) และ
โพสต์ที่มีความอันตรายจะมี bitstring ที่อันตรายเป็น substring อยู่ โดยในการจำลองครั้งนี้
bitstring ที่อันตรายจะมีรูปแบบเดียวที่ความยาว $X$ ($3 \le X \le 64$)

AI ของ Facebook นั้นได้รับการขนานนามจากความ \textbf{ดี ย์}งามของมัน
นักพัฒนาของเฟสบุ๊คยึดหลัก Learn on \textbf{P r o d u c t i o n}

คุณจะมีโพสต์ทั้งหมด $N$ โพสต์ซึ่งเป็นโพสต์บน Production \textbf{จริงๆ} ที่คุณจะต้องตัดสินว่า
เป็นไปตาม\textit{มาตรฐานชุมชน}หรือไม่ แล้วเรียนรู้กับมันไปพร้อมกัน

คุณจะต้องเขียนฟังก์ชันต่อไปนี้

\begin{verbatim}
bool follows_community_standard(int i, string post);
\end{verbatim}

ซึ่งจะรับค่า $i$ แทนลำดับของโพสต์ปัจจุบัน และบิทสตริงแล้วต้องรีเทิร์น\textbf{ทันที}
ว่าตรงกับ\textit{มาตรฐานชุมชน}หรือไม่

ในกรณีที่การตัดสินของคุณถูกต้อง ก็จะไม่มีอะไรเกิดขึ้น แต่ถ้าคุณตัดสินผิดจะมีสิ่งที่เกิดขึ้นได้ 2 กรณี

1. กรณีที่โพสต์นั้นขัดกับมาตรฐานชุมชนแล้ว AI ของคุณไม่ทำอะไร ก็ย่อมมีคนที่มาช่วยกดรีพอร์ต นั่นคือจะมี
โอกาส $R\%$ ที่ AI ของคุณจะได้รู้ว่าจริงๆแล้ว โพสต์นี้ขัดกับมาตรฐานชุมชน

2. กรณีที่โพสต์นั้นไม่ขัดกับมาตรฐานชุมชน แต่ AI ของคุณไปทำให้โพสต์นั้นบิน
ย่อมมีโอกาสสูงที่คุณจะถูกโต้แย้ง นั่นคือมีโอกาส $A\%$ ที่ AI
ของคุณจะได้รู้ว่าโพสต์นี้ไม่ได้ขัดมาตรฐานชุมชน

ทุกครั้งที่มีการโต้แย้ง จะมีคนจริงๆคอยตรวจสอบเสมอ นั่นคือผลการโต้แย้งเป็นสิ่งที่ถูกต้องแล้ว 
(หากมันเกิดขึ้น)

คุณสามารถรู้ได้ว่ามีการโต้แย้งหรือไม่ โดยการเรียกฟังก์ชัน

\begin{verbatim}
bool get_last_result();
\end{verbatim}

ซึ่งจะรีเทิร์น true หากมีการรายงานหรือโต้แย้ง ในการตัดสินครั้งล่าสุดของคุณ
ฟังก์ชันนี้จะโยน exception หากคุณเรียกมันในการรีวิวโพสต์ครั้งแรก (นั่นคือยังไม่มีผลการโต้แย้งใดๆ)

ในตอนเริ่มต้นของโปรแกรม ฟังก์ชันนี้ซึ่งคุณจะต้องเขียน จะถูกเรียก

\begin{verbatim}
void init_smart_ai(int N, int X, int R, int A);
\end{verbatim}

\Scoring

การวัดประสิทธิภาพของ AI นั้นจะมีสูตรการคำนวณดังนี้

\[\frac{\sum_{i=1}^{N} w_i * P_i}{\sum_{i=1}^{N} w_i}\]

โดย $P_i$ เท่ากับ $1$ เมื่อ AI ของคุณตัดสินโพสต์ที่ $i$ \textbf{อย่างถูกต้อง} และ $0$ หากไม่ใช่

และแน่นอนว่าช่วงแรกๆ AI มักจะทำผิดพลาด\textit{อย่างที่เราเห็นกันในทุกวันนี้} การจะตัดสิน AI จาก
ประสิทธิภาพช่วงแรกๆจึงไม่แฟร์นัก ดังนั้นจึงมีค่า $w_i$ ที่มาช่วยถ่วงน้ำหนักโดย

\[w_i = 1 - \frac{1}{e^{\frac{100}{69}*\frac{i}{N}}}\]

สรุปได้ว่าค่าประสิทธิภาพของคุณจะมีค่าระหว่าง $0$ เมื่อตัดสินผิดหมด ถึง $1$ เมื่อตัดสินถูกหมด
แน่นอนว่าในโลกนี้ไม่มี AI ที่สมบูรณ์ดังนั้น ค่าประสิทธิภาพของคุณจะถูกนำมาเทียบกับของกรรมการ

โดยให้ $P$ แทนคะแนนที่คุณได้ และ $T$ แทนคะแนนที่กรรมการสามารถทำได้ (จะมีการบอกในไฟล์แนบ)

\begin{center}
\begin{tabular}{ | c | c | }
\hline
\textbf{เงื่อนไข} & \textbf{อัตราส่วนคะแนนที่ได้ต่อคะแนนเต็ม} \\
\hline
$P \ge 0.95 * T$ & $1$ \\
\hline
$P < 0.95 * T$ & $(\frac{S}{T})^{1.69}$ \\
\hline
\end{tabular}
\end{center}

\Subtasks

$3 \le X \le 64,\ X \le S_i \le 256,\ 50 \le R, A \le 100$

\textbf{ขอบเขตของปัญหาย่อยที่ 1-3}

$N = 10\ 000,\ S_i \le 32,\ X \le 8$

1. (20 คะแนน) $R = 100, A = 100$

2. (17 คะแนน) $R = 50, A = 100$ ทุกโพสต์ที่ขัดกับมาตรฐานชุมชนจะมีความยาวเท่ากับ $X$ เสมอ

3. (12 คะแนน) $R = 50, A = 80$ ทุกโพสต์ที่ขัดกับมาตรฐานชุมชนจะมีความยาวเท่ากับ $X$ เสมอ

\textbf{ขอบเขตของปัญหาย่อยที่ 4-5}

$N = 100\ 000$

4. (29 คะแนน) $R = 50, A = 90$

5. (22 คะแนน) $R = 50, A = 80$

\Ex

กำหนดให้ $X = 110$

เริ่มต้นมีการเรียกฟังก์ชัน

\begin{verbatim}
init_smart_ai(100, 3, 100, 100);
\end{verbatim}

จากนั้นได้มีการตรวจโพสต์แรก

\begin{verbatim}
follows_community_standard(1, "10110");
\end{verbatim}

ซึ่งคุณได้รีเทิร์น true ไปก่อน จากนั้นก็มีการเรียก

\begin{verbatim}
follows_community_standard(1, "1010011");
\end{verbatim}

ภายในการเรียกครั้งที่สอง คุณได้เรียก get\_last\_result() แล้วพบว่าฟังก์ชันนี่รีเทิร์น true

คุณจึงได้ว่าสตริง $X$ มีโอกาสเป็น $101, 011$ หรือ $110$ คุณจึงรีเทิร์น false ในฟังก์ชันนี่ไปก่อน

และภายในการเรียกฟังก์ชันครั้งต่อไป get\_last\_result() รีเทิร์น true
ทำให้คุณทราบว่า $X$ คือ $110$ และหลังจากนี้ AI ของคุณก็สามารถที่จะตัดสินใจอย่างถูกต้องได้แล้ว

\end{problem}

\end{document}
